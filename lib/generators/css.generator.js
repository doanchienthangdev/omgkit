/**
 * CSS Generator
 * Generates CSS variables from theme (v1 and v2 compatible)
 *
 * @module lib/generators/css
 */

import { detectThemeVersion, isV2Theme } from '../theme.js';
import {
  processTheme,
  processAnimations,
  generateKeyframesCSS
} from '../theme-v2.js';

/**
 * Generate CSS from theme
 * @param {Object} theme - Theme object (v1 or v2)
 * @param {Object} options - Generation options
 * @param {boolean} options.includeBase - Include @layer base wrapper (default: true)
 * @param {boolean} options.includeReset - Include border-box reset (default: true)
 * @param {boolean} options.includeAnimations - Include keyframes (default: true)
 * @returns {string} CSS content
 */
export function generateCSS(theme, options = {}) {
  const {
    includeBase = true,
    includeReset = true,
    includeAnimations = true
  } = options;

  const result = processTheme(theme);
  const { light: lightVars, dark: darkVars } = result.variables;

  // Generate variable declarations
  const generateVars = (vars) => {
    return Object.entries(vars)
      .map(([key, value]) => `  --${key}: ${value};`)
      .join('\n');
  };

  const lightCSS = generateVars(lightVars);
  const darkCSS = generateVars(darkVars);

  // Typography
  const fontSans = theme.typography?.fontFamily?.sans ||
                   theme.fontFamily?.sans ||
                   'Inter, system-ui, sans-serif';
  const fontMono = theme.typography?.fontFamily?.mono ||
                   theme.fontFamily?.mono ||
                   'JetBrains Mono, monospace';
  const radius = theme.spacing?.radius || theme.radius || '0.5rem';

  // Animations
  let keyframesCSS = '';
  let animationVars = '';

  if (includeAnimations && theme.animations) {
    const { keyframes, animations } = processAnimations(theme.animations);
    keyframesCSS = generateKeyframesCSS(keyframes);
    animationVars = Object.entries(animations)
      .map(([name, value]) => `  --animation-${name}: ${value};`)
      .join('\n');
  }

  // Build CSS
  const version = detectThemeVersion(theme);
  let css = `/* OMGKIT Theme: ${theme.name} */
/* Theme ID: ${theme.id} */
/* Category: ${theme.category} */
/* Version: ${version} */
/* Generated by OMGKIT Design System */

`;

  // Add keyframes
  if (keyframesCSS) {
    css += keyframesCSS + '\n';
  }

  // Root variables
  if (includeBase) {
    css += `@layer base {
  :root {
${lightCSS}
  --radius: ${radius};
  --font-sans: ${fontSans};
  --font-mono: ${fontMono};
${animationVars ? animationVars + '\n' : ''}}

  .dark {
${darkCSS}
  }
}
`;
  } else {
    css += `:root {
${lightCSS}
  --radius: ${radius};
  --font-sans: ${fontSans};
  --font-mono: ${fontMono};
${animationVars ? animationVars + '\n' : ''}}

.dark {
${darkCSS}
}
`;
  }

  // Reset styles
  if (includeReset && includeBase) {
    css += `
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-family: var(--font-sans);
  }
}
`;
  } else if (includeReset) {
    css += `
* {
  border-color: hsl(var(--border));
}
body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
  font-family: var(--font-sans);
}
`;
  }

  return css;
}

/**
 * Generate CSS for a specific mode only
 * @param {Object} theme - Theme object
 * @param {string} mode - 'light' or 'dark'
 * @returns {string} CSS content for that mode
 */
export function generateCSSForMode(theme, mode = 'light') {
  const result = processTheme(theme, { mode });
  const vars = result.variables[mode] || {};

  return Object.entries(vars)
    .map(([key, value]) => `--${key}: ${value};`)
    .join('\n');
}
